# Azumi

> **The framework that catches your CSS typos before your users do.**

```rust
html! {
    <div class={button}>  // ‚ùå COMPILE ERROR: Did you mean `button`?
        "Click me"
    </div>
}
```

**Azumi** is a **compile-time validated web framework** for Rust. Your CSS classes, your HTML structure, your UI logic ‚Äî all verified before a single byte hits production.

No runtime errors. No "works on my machine". No surprises.

## üõ†Ô∏è Development Experience

Azumi includes a built-in, self-hosting hot reload system. Just add one line to your code:

```rust
fn main() {
    azumi::devtools::auto_reload(); // ‚ö° That's it!
    // Or tie it to a custom check:
    // azumi::devtools::auto_reload_if(config.dev_mode);
}
```

- **CSS**: Instant, zero-reload updates.
- **HTML**: Sub-second patching.
- **Logic**: Auto-restart on change.

## See [HOT_RELOAD.md](./HOT_RELOAD.md) for details.

## ‚ö° The Pitch

Traditional web frameworks let bugs slip through to production. Azumi doesn't.

| Other Frameworks              | Azumi                                  |
| ----------------------------- | -------------------------------------- |
| CSS typo ‚Üí silent fail        | CSS typo ‚Üí **compile error**           |
| Missing class ‚Üí invisible bug | Missing class ‚Üí **compile error**      |
| Invalid HTML ‚Üí maybe works?   | Invalid HTML ‚Üí **compile error**       |
| Click handler typo ‚Üí üíÄ       | Click handler typo ‚Üí **compile error** |

**Everything happens at compile time.** Your IDE shows errors before you save. Your CI fails before it deploys. Your users never see a broken page.

---

## üöÄ Features That Actually Matter

### 1. CSS-HTML Co-Validation (Industry First)

The compiler knows your styles. Use a class that doesn't exist? Error. Typo in a class name? Error. Define a class you never use? Warning.

```rust
html! {
    <div class={my_buttn}>  // ‚ùå "my_buttn" not found. Did you mean "my_button"?
        "Oops"
    </div>

    <style>
        .my_button { background: "#3b82f6"; }
    </style>
}
```

### 2. Optimistic UI (Hybrid: Auto + Manual)

Write Rust. Get instant UI. No JavaScript required.

**Automatic:** Simple mutations (assignments, toggles) are predicted automatically by the compiler.

```rust
#[azumi::live_impl]
impl Counter {
    pub fn increment(&mut self) {
        self.count += 1;  // ‚úÖ Compiler generates: data-predict="count = count + 1"
    }
}
```

**Manual:** Complex mutations (structs, vectors) use explicit hints.

```rust
// üöÄ Instant feedback for complex data
#[azumi::predict("todos.push(new_todo)")]
pub fn add_todo(&mut self) { ... }
```

### 3. Signed State (Anti-Tampering)

Every component's state is HMAC-signed. Users can't forge counts, bypass auth, or inject data. The server rejects tampered requests automatically.

```rust
// User tries to edit az-scope JSON in DevTools...
// ‚Üí 400 Bad Request. Automatically. No code needed.
```

### 4. Automatic SEO

Azumi infers metadata directly from your Rust code. Zero configuration required.

```rust
/// About Us
/// We are a team of passionate developers...
#[azumi::page]
pub fn about_us() -> impl Component { ... }
```

**Generates:** `<title>About Us</title>`, `<meta name="description" ...>`, OpenGraph tags, and Twitter cards automatically.

### 5. Production-Ready Asset Pipeline

- **Content-hashed filenames** ‚Üí Immutable caching (1 year)
- **Automatic path rewriting** ‚Üí Write `/static/logo.png`, get `/assets/logo.a8f3c2.png`
- **CSS minification** ‚Üí Zero config

---

## üö® Critical Rules (Must-Know)

### 1. CSS Values MUST Be Double-Quoted

```rust
// ‚úÖ CORRECT - all values quoted
.btn {
    padding: "1rem";
    background: "#4CAF50";
    color: "white";
    border-radius: "8px";
}

// ‚ùå WRONG - will cause compile errors or lexer issues
.btn {
    padding: 1rem;      // Lexer can't parse "1rem" as token
    background: #4CAF50; // # causes parsing issues
    color: white;        // Unquoted identifier
}
```

### 2. CSS Classes (`class={...}`)

- **Strict Snake Case:** All CSS classes MUST be `snake_case`. Dashes (`-`) are **BANNED** in class names (e.g., Use `.my_card`, NOT `.my-card`).
- **Bracket Syntax ONLY:** You must use brackets with variables. Static strings usage (`class="..."`) is **BANNED**.
- **No Magic:** Automatic scoping handles everything via variables.
- **Expression Lists:** You can combine multiple class variables.

```rust
html! {
    // ‚úÖ CORRECT: Use variables generated by macros
    <div class={my_card}>...</div>

    // ‚úÖ CORRECT: Combine multiple classes
    <div class={my_card active}>...</div>

    // ‚ùå INCORRECT: Quoted strings are BANNED
    // <div class="my_card">...</div>

    // ‚ùå INCORRECT: Dashed names are invalid Rust identifiers
    // <div class={my-card}>...</div>

    <style>
        .my_card { ... }
        .active { ... }
    </style>
}
```

### 3. IDs (`id={...}`)

- Same rules as classes: **Snake Case** and **Bracket Syntax ONLY**.
- `id="..."` is **BANNED**.

```rust
html! {
    <div id={my_unique_id}>...</div>
    <style>
        #my_unique_id { ... }
    </style>
}
```

### 4. Inline Styles (`style={...}`)

- Use the **Style DSL** with brackets.
- `style="..."` string syntax is **BANNED**.

```rust
// ‚úÖ CORRECT
<div style={ --color: "red"; --spacing: "1rem" }>...</div>

// ‚ùå INCORRECT
// <div style="--color: red">...</div>
```

### 5. Live State Requires Component Link

```rust
// State definition
#[azumi::live]
pub struct Counter { pub count: i32 }

// Implementation MUST specify component
#[azumi::live_impl(component = "counter_view")]  // ‚Üê Required!
impl Counter {
    pub fn increment(&mut self) { self.count += 1; }
}

// Component MUST match the name
#[azumi::component]
pub fn counter_view<'a>(state: &'a Counter) -> impl Component + 'a {
    html! { /* ... */ }
}
```

### 6. Event Binding Syntax

```rust
// ‚úÖ CORRECT - use on:event={state.method}
<button on:click={state.increment}>"Click"</button>

// ‚ùå WRONG - don't use closures or function calls
<button on:click={|| state.increment()}>"Click"</button>
<button on:click={state.increment()}>"Click"</button>
```

### 7. Text Content Must Be Quoted

```rust
// ‚úÖ CORRECT - all text in quotes
<p>"Hello world"</p>
<p>"Count: " {count}</p>

// ‚ùå WRONG - will cause parsing errors
<p>Hello world</p>
```

### 8. Style Order: HTML First, Style Last

For readability and consistency, always place your `<style>` block **after** your HTML content.

```rust
html! {
    // 1. Structure
    <div class={container}>...</div>

    // 2. Style
    <style>
        .container { ... }
    </style>
}
```

---

## üöÄ Setup & Configuration

### Injecting Client Runtime

Azumi is **Static by Default**. It does NOT automatically inject the client runtime.

- **Manual Injection (Required)**: You must manually include `<script src="azumi.js" />` in your layout if you want interactivity.
- **Static Optimized**: Pages without the script are pure, zero-JS static HTML.

```rust
#[azumi::component]
pub fn RootLayout(children: impl Component) -> impl Component {
    html! {
        <!DOCTYPE html>
        <html>
            <head>
                <meta charset="utf-8" />
                <title>"My Azumi App"</title>
            </head>
            <body>
                {children}

                // ‚ö†Ô∏è REQUIRED: Manually include the runtime for interactivity
                // This magic script is intercepted by the server.
                // Place this in your ROOT layout to inherit it across all pages.
                <script src="azumi.js" />
            </body>
        </html>
    }
}
```

---

## üì¶ Asset Pipeline & Optimization

Azumi includes a production-ready asset pipeline that handles hashing, rewriting, and optimization automatically.

### 1. Automatic Asset Hashing (Cache Busting)

- Place your static assets (images, fonts, etc.) in the `demo/static/` directory.
- At build time, Azumi moves them to `target/assets/` and renames them with a content hash:
  - `static/logo.png` -> `assets/logo.a8b9c7d6.png`
- This enables **immutable caching** (1 year cache lifetime), as file names change whenever content changes.

### 2. Automatic Path Rewriting

You do not need to manually import or reference hashed files. Just use the original path in your `html!` macro:

```rust
html! {
    // You write this:
    <img src="/static/logo.png" />

    // Compiler outputs this automatically:
    // <img src="/assets/logo.a8b9c7d6.png" />
}
```

- The macro reads `assets_manifest.json` at compile time to rewrite paths.
- Works for `src`, `href` (link tags), and `srcset`.

### 3. CSS Minification

- Styles defined in `<style>` blocks are automatically parsed and minified at compile time.
- Comments and whitespace are removed to reduce payload size.
- No configuration needed.

---

## üèóÔ∏è Component Fundamentals

### Basic Component Structure

```rust
#[azumi::component]
pub fn MyComponent(title: &str, count: i32) -> impl Component {
    html! {
        <div class={container}>
            <h1 class={title}>{title}</h1>
            <p>"Count: " {count}</p>
        </div>
        <style>
            .container { padding: "1rem"; }
            .title { font-size: "1.5rem"; color: "#333"; }
        </style>
    }
}
```

### Component with Children

```rust
#[azumi::component]
pub fn Container(children: impl Component) -> impl Component {
    html! {
        <div class={container}>
            {children}
        </div>
        <style>
            .container { padding: "1rem"; border: "1px solid #ddd"; }
        </style>
    }
}

// Usage with curly braces
@Container {
    <p>"Content inside container"</p>
    "Explicit strings are also components"
}

// Direct usage (String implements Component)
let my_comp = @Container(children = "Hello".to_string());
```

### Component Composition

```rust
#[azumi::component]
pub fn Card<'a>(title: &'a str, content: &'a str) -> impl Component + 'a {
    html! {
        <div class={card}>
            <h3 class={title}>{title}</h3>
            <p>{content}</p>
        </div>
        <style>
            .card { border: "1px solid #eee"; padding: "1rem"; }
            .title { font-weight: "bold"; margin-bottom: "0.5rem"; }
        </style>
    }
}

#[azumi::component]
pub fn Dashboard() -> impl Component {
    html! {
        <div>
            @Card(title="Welcome", content="Getting started")
            @Card(title="Features", content="Type-safe components")
        </div>
    }
}
```

---

## üé® Styling System

### CSS Scoping: Component vs Global

```rust
#[azumi::component]
pub fn StyledComponent() -> impl Component {
    html! {
        <div class={container}>
            <h1 class={local_heading}>"Scoped (blue)"</h1>
            <h2 class={global_heading}>"Global (purple)"</h2>
        </div>

        // Global styles - NOT scoped (use string literals)
        <style global>
            body { font-family: "Inter, sans-serif"; }
            .global_heading { color: "purple"; }
        </style>

        // Component styles - automatically scoped (become variables)
        <style>
            .local_heading { color: "blue"; }
            .container { padding: "1rem"; }
        </style>
    }
}
```

### Dynamic CSS with Custom Properties

```rust
#[azumi::component]
pub fn ProgressMeter(completion: f64, accent_color: &str) -> impl Component {
    html! {
        <div class={meter}>
            // style="" ONLY allows CSS custom properties (--variables)
            <div class={fill} style={--progress: completion; --accent: accent_color}></div>
        </div>

        <style>
            .meter {
                width: "100%";
                height: "20px";
                background: "#eee";
                border-radius: "10px";
                overflow: "hidden";
            }
            .fill {
                height: "100%";
                background: "var(--accent, #2196f3)";
                width: "calc(var(--progress) * 100%)";
                transition: "width 0.3s ease";
            }
        </style>
    }
}
```

**‚ö†Ô∏è Important**: Only CSS custom properties (`--var-name`) are allowed in `style=""` attributes. Direct properties like `style="width: 50%"` cause compile errors.

### CSS Validation Rules

Azumi validates all CSS at compile time:

**Allowed:**

- Standard CSS properties with quoted values
- CSS custom properties (`--variable-name`)
- CSS functions like `calc()`, `var()`, etc.

**Not Allowed:**

- External CSS imports (`@import`)
- Inline CSS properties without custom properties
- Invalid CSS syntax

---

## üßÆ Control Flow & Logic

### @let Pattern (Local Variables)

```rust
#[azumi::component]
pub fn LetExample() -> impl Component {
    html! {
        <div>
            // Basic variable declaration
            @let name = "Azumi";
            <p>"Hello, " {name} "!"</p>

            // Calculated values
            @let items = vec!["Item 1", "Item 2", "Item 3"];
            @let item_count = items.len();
            <p>"Total items: " {item_count}</p>

            // Derived calculations
            @let base_price = 100.0;
            @let tax_rate = 0.08;
            @let total_price = base_price * (1.0 + tax_rate);
            <div class={result}>
                <p>"Total: $" {total_price:.2}</p>
            </div>

            // With conditional logic
            @let score = 85;
            @let grade = if score >= 90 {
                "A"
            } else if score >= 80 {
                "B"
            } else {
                "C"
            };
            <p>"Grade: " {grade}</p>
        </div>
        <style>
            .result { background: "#f0f0f0"; padding: "0.5rem"; }
        </style>
    }
}
```

### Conditional Rendering (@if)

```rust
html! {
    // Simple conditional
    @if state.active {
        <div>"Active"</div>
    }

    // With else
    @if state.user_type == "admin" {
        <div>"Admin Panel"</div>
    } else {
        <div>"User Dashboard"</div>
    }

    // Conditional class application
    <div class={if state.active { "active_class" } else { "inactive_class" }}>
        "Content"
    </div>
}
```

### Loops (@for)

```rust
html! {
    // Basic loop
    @for item in &state.items {
        <div>{item}</div>
    }

    // Loop with index
    @for (i, item) in state.items.iter().enumerate() {
        <div>{i + 1}". " {item}</div>
    }

    // Empty state handling
    @if state.items.is_empty() {
        <p>"No items found"</p>
    } else {
        @for item in &state.items {
            <div>{item}</div>
        }
    }
}
```

### Pattern Matching (@match)

```rust
#[azumi::component]
pub fn StatusDisplay(status: &str) -> impl Component {
    html! {
        <div>
            @match status {
                "loading" => {
                    <p class={loading}>"Loading..."</p>
                }
                "success" => {
                    <p class={success}>"Operation successful!"</p>
                }
                "error" => {
                    <p class={error}>"An error occurred"</p>
                }
                _ => {
                    <p>"Unknown status"</p>
                }
            }
        </div>
        <style>
            .loading { color: "blue"; }
            .success { color: "green"; }
            .error { color: "red"; }
        </style>
    }
}
```

---

## ‚ö° Live Interactive Components

### Hybrid Optimistic UI

Azumi uses a **Hybrid Approach** to optimistic UI:

1.  **Automatic Predictions**: Simple updates are handled by the compiler.
2.  **Manual Predictions**: Complex logic uses `data-predict`.

#### 1. Automatic (Compiler-Driven)

For simple scalar operations, just write Rust. The compiler generates the prediction logic for you.

```rust
#[azumi::live_impl]
impl Counter {
    // Compiler sees: self.active = !self.active
    // Generates: data-predict="active = !active"
    pub fn toggle(&mut self) {
        self.active = !self.active;
    }

    // Compiler sees: self.count += 1
    // Generates: data-predict="count = count + 1"
    pub fn increment(&mut self) {
        self.count += 1;
    }
}
```

#### 2. Manual (Developer-Driven)

For complex types (Vectors, HashMaps) or logic the compiler can't predict safely, use the `data-predict` attribute manually.

```rust
html! {
    <button
        on:click={state.add_todo}
        // Manual hint: "When clicked, optimistic append"
        data-predict="todos.push({ text: input, id: -1 })"
    >
        "Add Todo"
    </button>
}
```

### Local State (Client-Only)

For temporary UI state (dropdowns, modals, tabs) that doesn't need to persist to the server, use the `set` action.

```rust
html! {
    // üöÄ updates state.open = true locally. No server request.
    <button az-on="click set open = true">
        "Open Modal"
    </button>

    // Toggle logic
    <button az-on="click set open = !open">
        "Toggle"
    </button>
}
```

### Async Database Integration

You can use `sqlx` directly in your async live actions. The UI can update optimistically while the DB operation happens in the background.

```rust
impl TodoList {
    pub async fn add_todo(&mut self) {
        // 1. Optimistic Update (Instant feedback)
        self.todos.push(Todo { id: -1, text: self.input.clone() });
        let input_val = self.input.clone();
        self.input.clear();

        // 2. Real Async DB Operation
        sqlx::query("INSERT INTO todos (text) VALUES (?)")
            .bind(input_val)
            .execute(&*POOL) // Use a global or injected pool
            .await
            .unwrap();

        // 3. Re-fetch for consistency (updates IDs, etc.)
        self.refresh_from_db().await;
    }
}
```

### Live Component View

```rust
#[azumi::component]
pub fn counter_view<'a>(state: &'a Counter) -> impl Component + 'a {
    html! {
        <div class={counter}>
            <div class={value}>{state.count}</div>
            <button class={btn} on:click={state.increment}>
                "Increment"
            </button>
            <p>"Status: " {if state.active { "Active" } else { "Inactive" }}</p>
        </div>
        <style>
            .counter { padding: "2rem"; text-align: "center"; }
            .value { font-size: "3rem"; margin: "1rem 0"; }
            .btn { padding: "1rem 2rem"; cursor: "pointer"; }
        </style>
    }
}
```

### Auto-Detection of Live Components

When the first parameter is `state: &T`, the component automatically detects live mode:

```rust
// Auto-wraps in <div az-scope="...">
#[azumi::component]
pub fn auto_detected_view<'a>(state: &'a MyState) -> impl Component + 'a {
    html! {
        <button on:click={state.my_action}>"Click me"</button>
    }
}
```

---

## üéØ Event Binding Systems

### Modern: on:event Syntax (Recommended)

```rust
<button on:click={state.increment}>"Click"</button>
<input on:input={state.update_text} />
<form on:submit={state.submit_form}>"Submit"</form>
```

---

## üìã Form Handling

### Basic Form with Live State

```rust
#[azumi::live]
pub struct ContactForm {
    pub submitted: bool,
}

#[azumi::live_impl]
impl ContactForm {
    pub fn submit(&mut self) {
        self.submitted = true;
    }

    pub fn reset(&mut self) {
        self.submitted = false;
    }
}

#[azumi::component]
pub fn contact_form_view<'a>(state: &'a ContactForm) -> impl Component + 'a {
    html! {
        @if state.submitted {
            <div>"Thank you for your message!"</div>
            <button on:click={state.reset}>"Send Another"</button>
        }

        @if !state.submitted {
            <form class={form}>
                <div class={field}>
                    <label>"Name"</label>
                    <input class={input} type="text" name="name" />
                </div>
                <div class={field}>
                    <label>"Email"</label>
                    <input class={input} type="email" name="email" />
                </div>
                <button class={btn} type="button" on:click={state.submit}>
                    "Submit"
                </button>
            </form>
        }
        <style>
            .form { display: "grid"; gap: "1rem"; max-width: "400px"; }
            .field { display: "grid"; gap: "0.5rem"; }
            .input { padding: "0.5rem"; border: "1px solid #ddd"; }
            .btn { padding: "0.75rem"; background: "#2196f3"; color: "white"; }
        </style>
    }
}
```

### Data Bind Attributes for Optimistic UI

The `data-bind` attribute enables optimistic UI updates by binding state properties to DOM elements:

```rust
#[azumi::component]
pub fn LiveCounter(state: &Counter) -> impl Component {
    html! {
        <div class={counter}>
            <div class={value} data-bind="count">{state.count}</div>
            <p>"Status: "
                <span data-bind="active">
                    {if state.active { "Active ‚úì" } else { "Inactive ‚úó" }}
                </span>
            </p>
        </div>
        <style>
            .counter { padding: "2rem"; text-align: "center"; }
            .value { font-size: "3rem"; color: "#2196f3"; }
        </style>
    }
}
```

**How it works:**

- The `data-bind="count"` attribute binds the `count` property from state
- When a prediction updates `count`, the corresponding DOM element updates instantly
- Supports nested properties: `data-bind="user.profile.name"`

### Form Binding with Structs

```rust
struct UserRegistration {
    username: String,
    email: String,
    password: String,
}

#[azumi::component]
pub fn RegistrationForm() -> impl Component {
    html! {
        <form class={form} bind={UserRegistration}>
            <input class={input} name="username" type="text" placeholder="Username" />
            <input class={input} name="email" type="email" placeholder="Email" />
            <input class={input} name="password" type="password" placeholder="Password" />
            <button type="submit">"Register"</button>
        </form>
        <style>
            .form { display: "grid"; gap: "1rem"; max-width: "400px"; }
            .input { padding: "0.5rem"; border: "1px solid #ddd"; }
        </style>
    }
}
```

### Nested Form Binding

```rust
struct UserProfile {
    name: String,
    address: Address,
}

struct Address {
    street: String,
    city: String,
}

#[azumi::component]
pub fn ProfileForm() -> impl Component {
    html! {
        <form bind={UserProfile}>
            <input name="name" type="text" placeholder="Full name" />
            <input name="address.street" type="text" placeholder="Street address" />
            <input name="address.city" type="text" placeholder="City" />
        </form>
    }
}
```

**Form Binding Rules:**

- Field names must match struct field names (case-sensitive)
- Nested fields use dot notation: `address.street`
- Compile-time validation prevents typos in field names
- Supports all form elements: `<input>`, `<select>`, `<textarea>`

---

## Authentication & Middleware

### The Data Bridge Pattern

Azumi components are pure Rust structs that know nothing about HTTP requests. Middleware is pure HTTP logic. You bridge them in your **Handler**.

You don't need to change Azumi internals to support auth; you just need to **pass the data**.

#### 1. The Guard (Middleware)

Standard Axum middleware validates the request and puts a `User` object into the request's "pocket" (extensions).

```rust
async fn auth_middleware(req: Request, next: Next) -> Result<Response, StatusCode> {
    // 1. Validate Session
    let user = decode_session_cookie(&req)?;

    // 2. data-passing: Put user in the request extensions
    req.extensions_mut().insert(user);

    Ok(next.run(req).await)
}
```

#### 2. The Bridge (Handler)

Your handler extracts that `User` object and gives it to the Azumi state.

```rust
async fn my_page_handler(
    // 3. Extract from request extensions
    Extension(user): Extension<User>
) -> impl IntoResponse {
    // 4. Initialize Azumi State
    let state = MyState {
        username: user.username,
        role: user.role
    };

    // 5. Render
    azumi::render_to_string(&MyComponent::render(
        MyComponent::Props::builder().state(&state).build().unwrap()
    ))
}
```

#### 3. The UI (Component)

The component just receives data. It doesn't care if it came from a cookie, a JWT, or a mock.

```rust
#[azumi::live]
pub struct MyState {
    pub username: String, // Just data!
}
```

### The Reusable Extractor Pattern (Recommended)

Instead of manually extracting `Extension` or implementing complex traits in every handler, we recommend creating a shared `CurrentUser` extractor in your project's infrastructure.

1. **Define Infrastructure (Once)**:
   Create a reusable extractor in `auth.rs`:

   ```rust
   // auth.rs
   pub struct CurrentUser(pub Option<User>);

   #[async_trait]
   impl<S> FromRequestParts<S> for CurrentUser where S: Send + Sync {
       async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
           let Extension(user) = parts.extract::<Extension<Option<User>>>().await.unwrap_or(Extension(None));
           Ok(CurrentUser(user))
       }
   }
   ```

2. **Use it Everywhere**:
   Now your handlers remain clean and Type-Safe:

   ```rust
   // page.rs
   use crate::auth::CurrentUser;

   pub async fn my_handler(
       // Look how clean this is!
       CurrentUser(user): CurrentUser
   ) -> impl IntoResponse {
       // Initialize state directly from the user object
       let state = MyState {
           name: user.map(|u| u.name)
       };
       azumi::render(&view(&state))
   }
   ```

---

## üñºÔ∏è Image Optimization

Azumi automatically optimizes images at compile time. You do not need a special image component.

### Automatic Attributes

Standard `<img>` tags automatically get performance attributes injected by the compiler:

```rust
// You write:
<img src="/photo.jpg" alt="Description" />

// Compiler generates:
<img src="/photo.jpg" alt="Description" loading="lazy" decoding="async" />
```

### Overriding Defaults

You can manually override these defaults for "above the fold" hero images:

```rust
// Hero image (loads immediately)
<img src="/hero.jpg" alt="Hero" loading="eager" />
// Compiler respects your choice and does NOT inject loading="lazy"
```

### Responsive Images

Use standard HTML `srcset` for responsive sizing. The compiler leaves these alone (while still adding lazy/async if omitted).

```rust
<img
    src="/photo-800.jpg"
    srcset="/photo-400.jpg 400w, /photo-800.jpg 800w"
    sizes="(max-width: 600px) 100vw, 800px"
    alt="Responsive"
/>
```

---

## üöÄ Performance Considerations

### Optimized Patterns

```rust
// ‚úÖ Good - minimal re-renders
#[azumi::component]
pub fn OptimizedComponent(state: &'a MyState) -> impl Component + 'a {
    html! {
        @let computed_value = expensive_calculation(&state.data);
        <div>{computed_value}</div>
    }
}

// ‚úÖ Good - conditional rendering
@if state.visible {
    @ExpensiveComponent(data=state.data)
}
```

### Avoid Anti-Patterns

```rust
// ‚ùå Bad - unnecessary computations in template
<div>
    {expensive_function(&state.data)}  // Runs on every render
</div>

// ‚ùå Bad - large components
// Break into smaller components instead
```

---

## üîß Debugging & Development

### Development Server

```bash
# Run the demo to see examples
cd demo
cargo run
# Visit http://localhost:3000
```

### Client Runtime (Manual Opt-In)

Azumi is **static by default**. Pages render as pure HTML with zero JavaScript.

To enable interactivity (Live components, optimistic UI), add the runtime script to your root layout:

```rust
#[azumi::component]
pub fn RootLayout(children: impl Component) -> impl Component {
    html! {
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8" />
            <title>"My App"</title>
        </head>
        <body>
            {children}

            // ‚ö†Ô∏è REQUIRED for Live features
            // This is a virtual file served by the framework
            <script src="azumi.js" />
        </body>
        </html>
    }
}
```

**Why manual?** You control the bundle. Static pages stay at 0kb JS. Interactive pages get only what they need (~12kb).

### CSS ID Handling

```rust
// IDs are NOT scoped like classes - they remain global
<style>
    #unique_id { color: "blue"; }  // ID not scoped
    .my_class { padding: "1rem"; } // Class gets scoped
</style>

// Usage
<div id={unique_id} class={my_class}>
    "Content"
</div>
```

### Error Messages

Common error patterns and solutions:

1. **CSS Parsing Errors**: Check all values are quoted
2. **Component Link Errors**: Ensure `#[azumi::live_impl(component = "name")]` matches component name
3. **Event Binding Errors**: Use `on:click={state.method}` not closures
4. **HTML Validation Errors**: Check required attributes (alt, href, labels)

---

## ‚ùå Common Mistakes

### Missing State Reference in Component

```rust
// WRONG - state must be first param for live components
#[azumi::component]
pub fn counter_view() -> impl Component { }

// CORRECT
#[azumi::component]
pub fn counter_view<'a>(state: &'a Counter) -> impl Component + 'a { }
```

### Using style Attribute Incorrectly

```rust
// WRONG - direct CSS properties
<div style={width: "50%"; background: "red"}></div>

// CORRECT - only CSS custom properties
<div style={--width: "0.5"; --color: "red"}></div>
```

### Closure Event Handlers

```rust
// WRONG - don't use closures
<button on:click={|| state.increment()}>

// CORRECT - direct method reference
<button on:click={state.increment}>
```

---

## üìö Quick Reference

| Feature       | Syntax                                 | Example                                              |
| ------------- | -------------------------------------- | ---------------------------------------------------- |
| Component     | `#[azumi::component]`                  | `#[azumi::component] fn MyComp() -> impl Component`  |
| Live State    | `#[azumi::live]`                       | `#[azumi::live] pub struct State { }`                |
| Live Methods  | `#[azumi::live_impl]`                  | `#[azumi::live_impl(component = "view")] impl State` |
| Event         | `on:event={state.method}`              | `on:click={state.increment}`                         |
| Class         | `class={class_name}`                   | `class={my_button}`                                  |
| Style         | `<style>` or `<style global>`          | `<style> .btn { } </style>`                          |
| Dynamic Style | `style={--var: value}`                 | `style={--color: "red"}`                             |
| Conditional   | `{if cond { a } else { b }}`           | `{if active { "On" } else { "Off" }}`                |
| Loop          | `@for item in items { }`               | `@for item in &list { <div>{item}</div> }`           |
| Pattern Match | `@match value { }`                     | `@match status { "ok" => {} _ => {} }`               |
| Local Var     | `@let name = value;`                   | `@let total = price * quantity;`                     |
| Children      | `@Component { }`                       | `@Container { <p>"Content"</p> }`                    |
| Head Meta     | `head! { title: "", description: "" }` | `head! { title: "Page", desc: "Desc" }`              |
| Schema        | `#[derive(Schema)]`                    | `#[schema(type = "BlogPosting")]`                    |
| Form Bind     | `bind={StructName}`                    | `form bind={UserRegistration}`                       |
| Data Bind     | `data-bind="property"`                 | `data-bind="count"`                                  |
| Client Script | `Auto / {azumi::azumi_script()}`       | `html! { <head>...` (Auto)                           |
| Text          | Quoted strings / Component             | `"Hello world"` / `String`                           |

---

## üìö Complete Learning Journey (20 Interactive Lessons)

Azumi includes the **most comprehensive web framework education platform** with hands-on lessons:

| Lesson | Topic                   | What You'll Learn                                  |
| ------ | ----------------------- | -------------------------------------------------- |
| **0**  | Components Basics       | `#[azumi::component]`, `html!` macro, basic syntax |
| **1**  | CSS Scoping             | Automatic CSS scoping, no naming conflicts         |
| **2**  | Global vs Scoped        | `<style>` vs `<style global>` patterns             |
| **3**  | Component Composition   | Building complex UIs from simple components        |
| **4**  | Children Pattern        | `children: impl Component` parameter               |
| **5**  | @let Variables          | Local variable declarations in templates           |
| **6**  | Control Flow            | `@if`, `@for`, `@match` patterns                   |
| **7**  | Form Handling           | Compile-time form validation                       |
| **8**  | Server Actions          | `#[azumi::action]` for interactivity               |
| **9**  | Azumi Live Intro        | Compiler-driven optimistic UI                      |
| **10** | Live Components         | Auto-detecting live state in components            |
| **11** | Event Binding           | `on:click={state.method}` declarative syntax       |
| **12** | Optimistic UI Flow      | How predictions work ‚Üí confirm                     |
| **13** | Form Patterns           | Live forms with server validation                  |
| **14** | Component Composition   | Complex UIs with live components                   |
| **15** | Full Application        | Complete todo app pattern                          |
| **16** | Async Database          | Real-world `sqlx` database integration             |
| **17** | Testing Infrastructure  | `azumi::test` for unit & simulation tests          |
| **18** | Security (Signed State) | HMAC-SHA256 protecting client-side state           |
| **19** | Authentication          | Axum middleware integration patterns               |

### üéì **Try the Interactive Learning Platform**

```bash
# Start the learning server
cd demo
cargo run

# Visit: http://localhost:3000
# - 20 interactive lessons with live examples
# - Progressive difficulty from basics to full apps
# - Real code examples you can modify and run
```

---

## üìä Performance Characteristics

| Metric                  | Azumi           | React      | Vue        | Svelte     |
| ----------------------- | --------------- | ---------- | ---------- | ---------- |
| **Bundle Size**         | ~5KB            | 100KB+     | 95KB+      | 50KB       |
| **First Paint**         | 50ms            | 500ms      | 400ms      | 200ms      |
| **Time to Interactive** | 100ms           | 1500ms     | 1200ms     | 400ms      |
| **CSS Validation**      | ‚úÖ Compile-time | ‚ùå Runtime | ‚ùå Runtime | ‚úÖ Runtime |
| **HTML Validation**     | ‚úÖ Compile-time | ‚ùå Runtime | ‚ùå Runtime | ‚ùå Runtime |

---

## üîÑ Comparison with Other Frameworks

| Feature                     | Azumi      | Next.js    | Phoenix LiveView | HTMX    |
| --------------------------- | ---------- | ---------- | ---------------- | ------- |
| **CSS-HTML Co-validation**  | ‚úÖ         | ‚ùå         | ‚ùå               | ‚ùå      |
| **Compile-time HTML**       | ‚úÖ         | ‚ùå         | ‚ùå               | ‚ùå      |
| **Automatic optimistic UI** | ‚úÖ         | Manual     | Manual           | ‚ùå      |
| **Bundle size**             | 5KB        | 200KB+     | 10KB             | 14KB    |
| **Type safety**             | Full Rust  | TypeScript | None             | None    |
| **Learning platform**       | 20 lessons | Examples   | Docs             | Minimal |

---

## üè¢ When to Use Azumi

### ‚úÖ **Azumi Excels At:**

**Correctness**

- **CSS-HTML co-validation** ‚Äî Typos, missing classes, invalid HTML caught at compile time
- **End-to-end type safety** ‚Äî DB struct ‚Üí component state ‚Üí HTML, zero schema drift
- **XSS prevention by default** ‚Äî Rust's type system enforces escaping

**Performance**

- **Zero hydration** ‚Äî No JS bundle replay, no `__NEXT_DATA__` blob, HTML is truth
- **~3kb runtime** ‚Äî Compare to Next.js (~80kb), Leptos (~150kb)
- **Instant TTI** ‚Äî No WASM download, no JS parse delay

**Developer Experience**

- **No API layer** ‚Äî DB queries live next to your components (no REST/tRPC ceremony)
- **Browserless testing** ‚Äî Unit test components without JSDOM or Cypress
- **Asset pipeline built-in** ‚Äî Content-hashed, immutable caching, zero config

**Production**

- **~90% cloud cost vs Node** ‚Äî Rust concurrency + low memory footprint
- **Signed state** ‚Äî HMAC prevents client-side tampering (no `isAdmin: true` hacks)
- **Edge-cacheable** ‚Äî Deterministic HTML, hashed assets, stateless servers

### üéØ **Outside Core Scope:**

- **Offline-first apps** ‚Äî Azumi assumes server is truth; offline requires separate sync layer
- **Continuous real-time sync** ‚Äî Collaborative editing, multiplayer games ‚Üí pair with dedicated real-time layer
- **Mobile native** ‚Äî Web-first ‚Üí wrap in Tauri/Capacitor for native distribution

Azumi is opinionated: logic runs on the server, UI updates are predicted, the server is truth. These aren't gaps ‚Äî they're the design.

## üìÅ Project Structure

```
azumi/
‚îú‚îÄ‚îÄ src/                    # Core framework
‚îÇ   ‚îú‚îÄ‚îÄ lib.rs             # Component traits, LiveState
‚îÇ   ‚îî‚îÄ‚îÄ action.rs          # Server actions
‚îú‚îÄ‚îÄ macros/                # Procedural macros
‚îÇ   ‚îú‚îÄ‚îÄ src/lib.rs         # Main macro entry point
‚îÇ   ‚îú‚îÄ‚îÄ src/component.rs   # #[azumi::component]
‚îÇ   ‚îú‚îÄ‚îÄ src/live.rs        # #[azumi::live] + #[azumi::live_impl]
‚îÇ   ‚îú‚îÄ‚îÄ src/style.rs       # CSS validation & scoping
‚îÇ   ‚îú‚îÄ‚îÄ src/token_parser.rs # HTML parsing
‚îÇ   ‚îî‚îÄ‚îÄ src/css_validator.rs # Compile-time validation
‚îú‚îÄ‚îÄ demo/                  # Interactive learning platform
‚îÇ   ‚îú‚îÄ‚îÄ src/examples/lessons/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/lesson0.rs through lesson19.rs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ components/layout.rs
‚îÇ   ‚îî‚îÄ‚îÄ src/main.rs        # Learning server
‚îî‚îÄ‚îÄ client/                # Browser runtime (5KB)
    ‚îú‚îÄ‚îÄ azumi.js           # Event handling, predictions
    ‚îî‚îÄ‚îÄ idiomorph.js       # DOM morphing
```

---

## üöÄ Quick Start

### 1. Create Your First Component

```rust
use azumi::html;

#[azumi::component]
pub fn WelcomeCard(name: &str) -> impl azumi::Component {
        <div class={welcome_card}>
            <h2 class={title}>"Welcome to Azumi!"</h2>
            <p>{"Hello, "}{name}{" üëã"}</p>
        </div>
        <style>
            .welcome_card {
                padding: "1.5rem";
                background: "linear-gradient(135deg, #667eea 0%, #764ba2 100%)";
                color: "white";
                border-radius: "12px";
            }
            .title { font-size: "1.5rem"; font-weight: "bold"; }
        </style>
    }
}
```

### 2. Add Interactivity with Azumi Live

```rust
use azumi::prelude::*;

// Define reactive state
#[azumi::live]
pub struct Counter {
    pub count: i32,
    pub liked: bool,
}

// Analyze mutations for predictions
#[azumi::live_impl(component = "counter_view")]
impl Counter {
    pub fn increment(&mut self) { self.count += 1; }
    pub fn toggle_like(&mut self) { self.liked = !self.liked; }
}

// Create live component
#[azumi::component]
pub fn counter_view<'a>(state: &'a Counter) -> impl Component + 'a {
        <div class={counter}>
            <div class={value}>{state.count}</div>
            <button class={btn} on:click={state.increment}>
                {if state.liked { "‚ù§Ô∏è" } else { "ü§ç" }}
            </button>
        </div>
        <style>
            .counter { text-align: "center"; padding: "2rem"; }
            .value { font-size: "3rem"; margin: "1rem 0"; }
            .btn { padding: "1rem 2rem"; margin: "0.5rem"; }
        </style>
    }
}
```

---

## ü§ù Getting Started

### **Option 1: Try the Learning Platform**

```bash
git clone https://github.com/DraconDev/azumi
cd azumi
cargo run -p demo
# Visit: http://localhost:3000
# Now featuring the "Deep Space" premium dark theme!
```

### **Option 2: Create a New Project**

```bash
cargo new my-azumi-app
cd my-azumi-app
# Add azumi to your Cargo.toml
cargo add azumi
```

### **Option 3: Follow the Lessons**

1. Start with **Lesson 0**: Components Basics
2. Progress through **Lessons 1-8**: Core framework features
3. Master **Lessons 9-19**: Azumi Live and advanced patterns
4. Build your first **full application**

---

## üéØ Key Takeaways

1. **Write Rust, get JavaScript**: The compiler does the heavy lifting
2. **Quote everything**: CSS values, text content, class names
3. **Component link required**: Live state needs `#[azumi::live_impl(component = "name")]`
4. **Event binding is declarative**: `on:click={state.method}` not closures
5. **Predictions are optimistic**: Server always wins if wrong
6. **CSS scoping is automatic**: No manual CSS management needed
7. **Forms are type-safe**: Compile-time validation for accessibility
8. **Performance is built-in**: Compiler optimizations and efficient rendering

---

## üìÑ License

MIT License - see [LICENSE](LICENSE) for details.

---

**üéì Ready to revolutionize your web development with compile-time safety?**

**[Start Learning ‚Üí](http://localhost:3000)** | **[GitHub ‚Üí](https://github.com/DraconDev/azumi)** | **[Documentation ‚Üí](https://docs.rs/azumi)**

---

_The only web framework that validates your HTML, scopes your CSS, and generates optimistic UI from Rust code‚Äîall at compile time._
// dummy change
