# ðŸ—ï¸ Azumi Asset Pipeline: Technical Design

This document details the architecture for `azumi-assets`, a system to handle static assets with production-grade performance and caching.

## 1. Content-Addressable Hashing (Cache Busting)

**The Problem:** Browsers cache files based on URL. If you serve `/style.css`, change the file, and redeploy, users with the old cached version will see broken styles.

**The Solution:** Change the filename whenever the content changes.
`style.css` -> `style.8f3a21.css`

### Implementation Strategy

We will use a `build.rs` (build script) to perform this work before the strict compilation phase.

#### A. The Build Script (`build.rs`)

1.  **Scan**: It recursively walks the `/assets` directory.
2.  **Hash**: For each file, it computes a SHA-256 hash of the bytes.
3.  **Copy & Rename**: It copies the file to `target/assets/` (or a distinctive build folder) with the new hashed name.
    -   `src: assets/logo.png`
    -   `dst: target/assets/logo.a8b9c2.png`
4.  **Generate Manifest**: It explicitly generates a Rust code file (`assets_manifest.rs`) containing a static map.

```rust
// Generated assets_manifest.rs (concept)
pub static ASSETS: phf::Map<&'static str, &'static str> = phf::phf_map! {
    "/css/main.css" => "/static/main.a8b9c2.css",
    "/img/logo.png" => "/static/logo.8f3a21.png",
};
```

#### B. **Automatic AST Rewriting** (The "Magic" Way)

Instead of forcing users to use a new syntax like `asset!(...)`, we leverage the existing `html!` macro.

**User Code remains standard HTML:**

```rust
html! {
    // The macro sees this string literal
    <img src="/img/logo.png" />
    <link rel="stylesheet" href="/css/main.css" />
}
```

**Macro Logic (`azumi-macros`):**

1.  **Load Manifest**: When the `html!` macro starts, it attempts to read the `assets.json` manifest generated by `build.rs`.
2.  **Intercept Attributes**: When parsing attributes `src`, `href`, or `srcset`:
3.  **Lookup**: If the value is a string literal starting with `/`, check the manifest.
4.  **Rewrite**: If a match is found (e.g., `/img/logo.png` -> `/static/logo.8f3a.png`), replace the string literal in the AST.

**Result:**
The user writes standard HTML, but the binary contains the optimized, hashed paths. Zero friction.

**Edge Cases:**

-   **Dynamic Values**: `<img src={user.avatar_url} />` cannot be optimized at compile time.
-   **External Links**: `https://...` are ignored.
-   **Missing Files**: If a local path `/img/typo.png` is not in the manifest, emit a compile-time warning or error (configurable).

---

## 2. CSS Processing & Minification

**The Problem:**

1.  `style` blocks in `html!` currently store raw strings with newlines and spaces.
2.  Components often duplicate common styles if not managed well.

### Implementation Strategy

#### A. Compile-Time Minification (In `azumi-macros`)

The `html!` macro parses the `<style>` block. Before emitting the Rust code that returns the string, we can run a minimal minifier.

**Input Code:**

```rust
html! {
    <style>
        .btn {
            color: red;
            padding: 1rem;
        }
    </style>
}
```

**Macro Logic:**
`azumi-macros` currently stores this as a string literal. We can add a function `minify_css(input: &str) -> String`.

**Transformation:**

1.  Remove comments `/* ... */`.
2.  Collapse whitespace: `\s+` -> ` `.
3.  Remove unnecessary spaces around punctuation: `:` -> `:`, `{` -> `{`.

**Generated Code:**

```rust
// The binary now contains this smaller string:
".btn{color:red;padding:1rem}"
```

#### B. Future: CSS Extraction (Advanced)

Later, we could extract these strings into a separate `.css` file during the build, instead of injecting them via JS/Style tags. This avoids "Flash of Unstyled Content" (FOUC).

---

## 3. Image Optimization

**The Problem:** Users upload 5MB PNGs. Browsers have to download 5MB.

### Implementation Strategy

We can use the `image` crate in our `build.rs`.

#### A. Automatic Conversion

When `build.rs` scans `/assets`:

1.  If it finds a `.png` or `.jpg`.
2.  It uses the `image` crate to load it.
3.  It encodes it as `WebP` (and/or `AVIF` if we want to be fancy).
4.  It saves the optimized version alongside the original in the build folder.

#### B. The `image!` Macro (Optional Helper)

We could provide a helper that generates the `<picture>` tag automatically.

```rust
html! {
    {azumi::image!("/img/hero.jpg")}
}

// Expands to:
<picture>
    <source srcset="/static/hero.a8b9.avif" type="image/avif" />
    <source srcset="/static/hero.c7d2.webp" type="image/webp" />
    <img src="/static/hero.8f3a.jpg" />
</picture>
```

---

## 4. Serving the Assets (Runtime)

We need an Axum handler to serve these files.

```rust
// main.rs
let app = Router::new()
    .route("/static/*path", get(serve_asset));

async fn serve_asset(Path(path): Path<String>) -> impl IntoResponse {
    // 1. Locate file in `target/assets/`
    // 2. Set Content-Type
    // 3. SET CACHE HEADERS:
    //    Cache-Control: public, max-age=31536000, immutable
}
```

Because the filename contains the hash (`logo.a8b9.png`), we can tell the browser to cache it **forever**. If the file changes, the hash changes, the filename changes, and the browser treats it as a completely new resource.

---

## 5. Summary of Benefits

1.  **Safety**: `asset!` macro prevents typos in file paths.
2.  **Speed**: Minified CSS and optimized Images load faster.
3.  **Caching**: Hashed filenames allow aggressive browser caching (instant subsequent loads).
4.  **Developer Experience**: You just drop files in `/assets` and use `asset!()`. The system handles the complex stuff.
